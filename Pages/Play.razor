@page "/play"
@using MyFirstCastlePanic.GameLogic

<PageTitle>Play Game</PageTitle>

<h1>Play My First Castle Panic</h1>

@if (!started)
{
	<label>Number of Players:
		<input type="number" min="2" max="4" @bind="playerCount" />
	</label>
	<button @onclick="StartGame">Start Game</button>
}
else if (engine != null && engine.State != null)
{
	<p>Game started with @playerCount players.</p>
	<p>Current Player: @(engine.State.CurrentPlayer + 1)</p>
	<!-- Phase indicator removed -->
	<h2>Board Spaces</h2>

	<div style="background:#eee; padding:0.5em; margin-bottom:1em;">
		<strong>DEBUG:</strong><br />
		Phase: @phase<br />
		Selected Card Index: @selectedCardIndex<br />
		Current Player Hand Count: @(engine != null && engine.State != null ? engine.State.PlayerHands[engine.State.CurrentPlayer].Count : 0)<br />
		Selected Card: @(selectedCardIndex.HasValue && engine != null && engine.State != null && engine.State.PlayerHands[engine.State.CurrentPlayer].Count > selectedCardIndex.GetValueOrDefault() ? engine.State.PlayerHands[engine.State.CurrentPlayer][selectedCardIndex.GetValueOrDefault()].Name : "None")<br />
		<br />
		<strong>Monsters on Board:</strong>
		<ul>
			@if (engine != null && engine.State != null)
			{
				foreach (var m in engine.State.MonstersOnBoard)
				{
					var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Index == m.SpaceIndex);
					<li>Monster: @m.Type @(m.IsStarred ? "★" : "") on Space @m.SpaceIndex (@(space != null ? space.Color + " " + space.Shape : "Unknown"))</li>
				}
			}
		</ul>
	</div>
	<ul>
		@foreach (var space in (engine != null && engine.State != null ? engine.State.BoardSpaces : new List<BoardSpace>()))
		{
			var hasMonster = (engine != null && engine.State != null) ? engine.State.MonstersOnBoard.Any(m => m.SpaceIndex == space.Index) : false;
			var showPlayButton = false;
			CastleCard? selectedCard = null;
				   if (phase == TurnPhase.Action && selectedCardIndex.HasValue && engine != null && engine.State != null)
				   {
					   int idx = selectedCardIndex.GetValueOrDefault();
					   if (engine.State.PlayerHands[engine.State.CurrentPlayer].Count > idx)
					   {
						   selectedCard = engine.State.PlayerHands[engine.State.CurrentPlayer][idx];
						   showPlayButton = hasMonster && CanPlayCardOnSpace(selectedCard, space);
					   }
				   }
			<li style="@(highlightedSpaceIndices.Contains(space.Index) ? "background-color: yellow;" : "")">
				@space.Index: <span style="@GetColorStyle(space.Color)">@space.Color</span> <span style="@GetColorStyle(space.Color)">@GetShapeIcon(space.Shape)</span>
				<span>
					@foreach (var monster in (engine != null && engine.State != null ? engine.State.MonstersOnBoard.Where(m => m.SpaceIndex == space.Index) : Enumerable.Empty<MonsterToken>()))
					{
						<span style="margin-left:10px;">@monster.Type @((monster.IsStarred ? "★" : ""))</span>
					}
					@if (showPlayButton)
					{
						   <button @onclick="() => { if (selectedCardIndex.HasValue && engine != null && engine.State != null) PlayCardOnSpace(selectedCardIndex.Value, space.Index); }">Play Card</button>
					}
				</span>
			</li>
		}
	</ul>

	<h2>Player Hands</h2>
	@for (int i = 0; engine != null && engine.State != null && i < engine.State.PlayerCount; i++)
	{
		<div>
			<strong>Player @(i+1):</strong>
			<ul>
				@for (int j = 0; engine != null && engine.State != null && j < engine.State.PlayerHands[i].Count; j++)
				{
					var card = engine.State.PlayerHands[i][j];
					var cardIdx = j;
					<li @onmouseover="() => HighlightSpaceForCard(card)" @onmouseout="ClearHighlight" style="@((selectedCardIndex == cardIdx && i == engine.State.CurrentPlayer) ? "background-color: #fff3cd; border: 3px solid #ff5722; box-shadow: 0 0 8px #ff9800;" : "border: 1px solid #ccc;")">
						<span style="color: #888; font-size: 0.9em; margin-right: 0.5em;">[Index: @cardIdx]</span>
						@if (card.Color.HasValue && card.Shape.HasValue)
						{
							<span style="@GetColorStyle(card.Color.Value)">@card.Color</span>
							<span style="@GetColorStyle(card.Color.Value)">@GetShapeIcon(card.Shape.Value)</span>
						}
						else if (card.IsHero)
						{
							<span style="font-weight:bold;">Hero: @card.Name</span>
						}
						else if (card.IsAnyColor && card.Shape.HasValue)
						{
							<span style="font-weight:bold;">Any-Color: @card.Name</span>
							@foreach (var color in new[] { MyFirstCastlePanic.GameLogic.CardColor.Blue, MyFirstCastlePanic.GameLogic.CardColor.Green, MyFirstCastlePanic.GameLogic.CardColor.Red })
							{
								<span style="@GetColorStyle(color)">@GetShapeIcon(card.Shape.Value)</span>
							}
						}
						else if (card.IsUtility)
						{
							<span style="font-weight:bold;">Utility: @card.Name</span>
						}
						else
						{
							<span>@card.Name</span>
						}
						<button @onclick="() => SelectCardForPlayer(i, cardIdx)">Select</button>
						<span style="color:#888; font-size:0.8em;">(SelectCardForPlayer(@i, @cardIdx))</span>
					</li>
				}
			</ul>
		</div>
	}

	<button @onclick="DrawCardForCurrentPlayer" disabled="@(phase != TurnPhase.DrawCard)">Draw Card</button>
	<button @onclick="MoveMonstersPhase" disabled="@(phase != TurnPhase.Action)">Move Monsters</button>
	<button @onclick="DrawMonsterPhase" disabled="@(phase != TurnPhase.DrawMonster)">Draw Monster</button>
	<button @onclick="() => { if (engine != null) engine.CheckGameOver(); }">Check Game Over</button>
}

@code {
	// Add TurnPhase enum for local use
	enum TurnPhase { DrawCard, Action, DrawMonster }

	// Track the current phase
	TurnPhase phase = TurnPhase.DrawCard;

	// Track the selected card and player
	int? selectedCardIndex = null;
	int? selectedPlayerIndex = null;

	// Allow selecting any card from any player
	void SelectCardForPlayer(int playerIndex, int cardIndex)
	{
		selectedPlayerIndex = playerIndex;
		selectedCardIndex = cardIndex;
		if (engine != null && engine.State != null
			&& playerIndex >= 0 && playerIndex < engine.State.PlayerHands.Count
			&& cardIndex >= 0 && cardIndex < engine.State.PlayerHands[playerIndex].Count)
		{
			var card = engine.State.PlayerHands[playerIndex][cardIndex];
			HighlightSpaceForCard(card);
		}
		StateHasChanged();
	}
	// GetPhaseLabel removed
	string GetColorStyle(MyFirstCastlePanic.GameLogic.CardColor color)
	{
		return color switch
		{
			MyFirstCastlePanic.GameLogic.CardColor.Blue => "color:blue;",
			MyFirstCastlePanic.GameLogic.CardColor.Green => "color:green;",
			MyFirstCastlePanic.GameLogic.CardColor.Red => "color:red;",
			_ => ""
		};
	}


	string GetShapeIcon(MyFirstCastlePanic.GameLogic.CardShape shape)
	{
		return shape switch
		{
			MyFirstCastlePanic.GameLogic.CardShape.Square => "■",
			MyFirstCastlePanic.GameLogic.CardShape.Triangle => "▲",
			MyFirstCastlePanic.GameLogic.CardShape.Circle => "●",
			_ => ""
		};
	}

	List<int> highlightedSpaceIndices = new();
	void HighlightSpaceForCard(CastleCard card)
	{
		highlightedSpaceIndices.Clear();
		if (engine != null && engine.State != null)
		{
			if (card.Color.HasValue && card.Shape.HasValue)
			{
				var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Color == card.Color && s.Shape == card.Shape);
				if (space != null)
					highlightedSpaceIndices.Add(space.Index);
			}
			else if (card.IsHero && card.Color.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Color == card.Color).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else if (card.IsAnyColor && card.Shape.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Shape == card.Shape).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else
			{
				highlightedSpaceIndices.Clear();
			}
		}
		StateHasChanged();
	}

	void ClearHighlight()
	{
		highlightedSpaceIndices.Clear();
		StateHasChanged();
	}
	GameEngine? engine = null;
	int playerCount = 2;
	bool started = false;

	void StartGame()
	{
		engine = new GameEngine(playerCount);
		started = true;
	}

	void DrawCardForCurrentPlayer()
	{
		if (phase == TurnPhase.DrawCard && engine != null && engine.State != null)
		{
			engine.DrawCard(engine.State.CurrentPlayer);
			phase = TurnPhase.Action;
			StateHasChanged();
		}
	}

	void SelectCard(int cardIndex)
	{
		selectedCardIndex = cardIndex;
		if (engine != null && engine.State != null && engine.State.PlayerHands[engine.State.CurrentPlayer].Count > cardIndex)
		{
			var card = engine.State.PlayerHands[engine.State.CurrentPlayer][cardIndex];
			HighlightSpaceForCard(card);
		}
		StateHasChanged();
	}

	void PlayCardOnSpace(int cardIndex, int spaceIndex)
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			bool played = engine.PlayCardOnSpace(engine.State.CurrentPlayer, cardIndex, spaceIndex);
			if (played)
			{
				selectedCardIndex = null;
				// Remain in Action phase so Move Monsters is still active
			}
			StateHasChanged();
		}
	}

	bool CanPlayCardOnSpace(CastleCard card, BoardSpace space)
	{
		if (card == null) return false;
		if (card.Color.HasValue && card.Shape.HasValue)
			return card.Color == space.Color && card.Shape == space.Shape;
		if (card.IsHero && card.Color.HasValue)
			return card.Color == space.Color;
		if (card.IsAnyColor && card.Shape.HasValue)
			return card.Shape == space.Shape;
		return false;
	}

	void MoveMonstersPhase()
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			engine.MoveMonsters();
			phase = TurnPhase.DrawMonster;
			StateHasChanged();
		}
	}

	void DrawMonsterPhase()
	{
		if (phase == TurnPhase.DrawMonster && engine != null && engine.State != null)
		{
			engine.DrawMonster();
			// TODO: Implement monster action
			phase = TurnPhase.DrawCard;
			engine.State.CurrentPlayer = (engine.State.CurrentPlayer + 1) % engine.State.PlayerCount;
			StateHasChanged();
		}
	}
	}

