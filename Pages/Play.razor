@page "/play"
@using MyFirstCastlePanic.GameLogic

<PageTitle>Play Game</PageTitle>

<h1>Play My First Castle Panic</h1>

@if (!started)
{
	<label>Number of Players:
		<input type="number" min="2" max="4" @bind="playerCount" />
	</label>
	<button @onclick="StartGame">Start Game</button>
}
else if (engine != null && engine.State != null)
{
	<p>Game started with @playerCount players.</p>
	<p>Current Player: @(engine.State.CurrentPlayer + 1)</p>
	<!-- Phase indicator removed -->
	<h2>Board Spaces</h2>

	<div style="background:#eee; padding:0.5em; margin-bottom:1em;">
		<strong>DEBUG:</strong><br />
		Phase: @phase<br />
		Selected Player Index: @selectedPlayerIndex<br />
		Selected Card Index: @selectedCardIndex<br />
		@if (selectedPlayerIndex.HasValue && selectedCardIndex.HasValue && engine != null && engine.State != null && selectedPlayerIndex.Value >= 0 && selectedPlayerIndex.Value < engine.State.PlayerHands.Count && selectedCardIndex.Value >= 0 && selectedCardIndex.Value < engine.State.PlayerHands[selectedPlayerIndex.Value].Count)
		{
			var debugCard = engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value];
			<div>Selected Card: @debugCard.Name (Color: @debugCard.Color, Shape: @debugCard.Shape, Hero: @debugCard.IsHero, AnyColor: @debugCard.IsAnyColor, Utility: @debugCard.IsUtility)</div>
		}
		else
		{
			<div>Selected Card: None</div>
		}
		<br />
		<strong>Monsters on Board:</strong>
		<ul>
			@if (engine != null && engine.State != null)
			{
				foreach (var m in engine.State.MonstersOnBoard)
				{
					var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Index == m.SpaceIndex);
					<li>Monster: @m.Type @(m.IsStarred ? "★" : "") on Space @m.SpaceIndex (@(space != null ? space.Color + " " + space.Shape : "Unknown"))</li>
				}
			}
		</ul>
		<strong>Board Spaces (for Catch Monster diagnosis):</strong>
		<ul>
		@if (engine != null && engine.State != null && selectedPlayerIndex.HasValue && selectedCardIndex.HasValue)
		{
			var pIdx = selectedPlayerIndex.Value;
			var cIdx = selectedCardIndex.Value;
			CastleCard? cardToPlay = null;
			if (pIdx >= 0 && pIdx < engine.State.PlayerHands.Count && cIdx >= 0 && cIdx < engine.State.PlayerHands[pIdx].Count)
			{
				cardToPlay = engine.State.PlayerHands[pIdx][cIdx];
			}
			foreach (var space in engine.State.BoardSpaces)
			{
				var hasMonster = engine.State.MonstersOnBoard.Any(m => m.SpaceIndex == space.Index);
				var canPlay = cardToPlay != null && CanPlayCardOnSpace(cardToPlay, space);
				var isUtility = cardToPlay != null && cardToPlay.IsUtility;
				<li>Space @space.Index: Monster? @hasMonster, CanPlay? @canPlay, Utility? @isUtility, ShowButton? @(hasMonster && (canPlay || isUtility))</li>
			}
		}
		</ul>
	</div>
	<ul>
		@foreach (var space in (engine != null && engine.State != null ? engine.State.BoardSpaces : new List<BoardSpace>()))
		{
			var hasMonster = (engine != null && engine.State != null) ? engine.State.MonstersOnBoard.Any(m => m.SpaceIndex == space.Index) : false;
			var showPlayButton = false;
			CastleCard? cardToPlay = null;
			if (phase == TurnPhase.Action && selectedCardIndex.HasValue && selectedPlayerIndex.HasValue && engine != null && engine.State != null)
			{
				int pIdx = selectedPlayerIndex.Value;
				int cIdx = selectedCardIndex.Value;
				if (pIdx >= 0 && pIdx < engine.State.PlayerHands.Count && cIdx >= 0 && cIdx < engine.State.PlayerHands[pIdx].Count)
				{
					cardToPlay = engine.State.PlayerHands[pIdx][cIdx];
					// Show button if there is a monster and the card can be played on this space
					showPlayButton = hasMonster && CanPlayCardOnSpace(cardToPlay, space);
					// For utility cards (e.g., Boot), allow button on any space with a monster
					if (cardToPlay != null && cardToPlay.IsUtility && hasMonster)
					{
						showPlayButton = true;
					}
				}
			}
			<li style="@(highlightedSpaceIndices.Contains(space.Index) ? "background-color: yellow;" : "")">
				@space.Index: <span style="@GetColorStyle(space.Color)">@space.Color</span> <span style="@GetColorStyle(space.Color)">@GetShapeIcon(space.Shape)</span>
				<span>
					@foreach (var monster in (engine != null && engine.State != null ? engine.State.MonstersOnBoard.Where(m => m.SpaceIndex == space.Index) : Enumerable.Empty<MonsterToken>()))
					{
						<span style="margin-left:10px;">@monster.Type @((monster.IsStarred ? "★" : ""))</span>
					}
					@if (showPlayButton)
					{
						<button @onclick="() => { if (selectedCardIndex.HasValue && selectedPlayerIndex.HasValue && engine != null && engine.State != null) PlayCardOnSpace(selectedPlayerIndex.Value, selectedCardIndex.Value, space.Index); }">Catch Monster</button>
					}
				</span>
			</li>
		}
	</ul>

	<h2>Player Hands</h2>

	@for (int i = 0; engine != null && engine.State != null && i < engine.State.PlayerCount; i++)
	{
		<div style="@(i == engine.State.CurrentPlayer ? "background-color: #e3f2fd; border: 2px solid #1976d2; padding: 0.5em; margin-bottom: 0.5em;" : "margin-bottom: 0.5em;")">
			<strong>Player @(i+1):</strong>
			<div style="display: flex; flex-direction: row; gap: 0.5em; align-items: flex-start; margin-top: 0.5em;">
				@for (int j = 0; engine != null && engine.State != null && j < engine.State.PlayerHands[i].Count; j++)
				{
					var card = engine.State.PlayerHands[i][j];
					var cardIdx = j;
					<div @onmouseover="() => HighlightSpaceForCard(card)" @onmouseout="ClearHighlight"
						 style="min-width: 90px; min-height: 60px; padding: 0.5em; margin: 0; display: flex; flex-direction: column; align-items: flex-start; justify-content: center; box-sizing: border-box; border-radius: 8px; background: #fff; box-shadow: 0 1px 4px #bbb; cursor: pointer; @(selectedCardIndex == cardIdx && selectedPlayerIndex == i ? "background-color: #fff3cd; border: 3px solid #ff5722; box-shadow: 0 0 8px #ff9800;" : "border: 1px solid #ccc;")">
						<span style="color: #888; font-size: 0.9em; margin-bottom: 0.2em;">[Index: @cardIdx]</span>
						@if (card.Color.HasValue && card.Shape.HasValue)
						{
							<span style="@GetColorStyle(card.Color.Value)">@card.Color</span>
							<span style="@GetColorStyle(card.Color.Value)">@GetShapeIcon(card.Shape.Value)</span>
						}
						else if (card.IsHero)
						{
							<span style="font-weight:bold;">Hero: @card.Name</span>
						}
						else if (card.IsAnyColor && card.Shape.HasValue)
						{
							<span style="font-weight:bold;">Any-Color: @card.Name</span>
							@foreach (var color in new[] { MyFirstCastlePanic.GameLogic.CardColor.Blue, MyFirstCastlePanic.GameLogic.CardColor.Green, MyFirstCastlePanic.GameLogic.CardColor.Red })
							{
								<span style="@GetColorStyle(color)">@GetShapeIcon(card.Shape.Value)</span>
							}
						}
						else if (card.IsUtility)
						{
							<span style="font-weight:bold;">Utility: @card.Name</span>
						}
						else
						{
							<span>@card.Name</span>
						}
						@if (phase == TurnPhase.Action)
						{
							<button @onclick="() => SelectCardForPlayer(i, cardIdx)" style="margin-top: 0.3em;">Play Card</button>
						}
						<span style="color:#888; font-size:0.8em;">(SelectCardForPlayer(@i, @cardIdx))</span>
					</div>
				}
			</div>
		</div>
	}

	<button @onclick="DrawCardForCurrentPlayer" disabled="@(phase != TurnPhase.DrawCard)">Draw Card</button>
	<button @onclick="MoveMonstersPhase" disabled="@(phase != TurnPhase.Action)">Move Monsters</button>
	<button @onclick="DrawMonsterPhase" disabled="@(phase != TurnPhase.DrawMonster)">Draw Monster</button>
	<button @onclick="() => { if (engine != null) engine.CheckGameOver(); }">Check Game Over</button>
}

@code {
	// Add TurnPhase enum for local use
	enum TurnPhase { DrawCard, Action, DrawMonster }

	// Track the current phase
	TurnPhase phase = TurnPhase.DrawCard;

	// Track the selected card and player
	int? selectedCardIndex = null;
	int? selectedPlayerIndex = null;

	// Allow selecting any card from any player
	void SelectCardForPlayer(int playerIndex, int cardIndex)
	{
		selectedPlayerIndex = playerIndex;
		selectedCardIndex = cardIndex;
		if (engine != null && engine.State != null
			&& playerIndex >= 0 && playerIndex < engine.State.PlayerHands.Count
			&& cardIndex >= 0 && cardIndex < engine.State.PlayerHands[playerIndex].Count)
		{
			var card = engine.State.PlayerHands[playerIndex][cardIndex];
			HighlightSpaceForCard(card);
		}
		// Ensure UI updates so Catch Monster button appears
		StateHasChanged();
	}
	// GetPhaseLabel removed
	string GetColorStyle(MyFirstCastlePanic.GameLogic.CardColor color)
	{
		return color switch
		{
			MyFirstCastlePanic.GameLogic.CardColor.Blue => "color:blue;",
			MyFirstCastlePanic.GameLogic.CardColor.Green => "color:green;",
			MyFirstCastlePanic.GameLogic.CardColor.Red => "color:red;",
			_ => ""
		};
	}


	string GetShapeIcon(MyFirstCastlePanic.GameLogic.CardShape shape)
	{
		return shape switch
		{
			MyFirstCastlePanic.GameLogic.CardShape.Square => "■",
			MyFirstCastlePanic.GameLogic.CardShape.Triangle => "▲",
			MyFirstCastlePanic.GameLogic.CardShape.Circle => "●",
			_ => ""
		};
	}

	List<int> highlightedSpaceIndices = new();
	void HighlightSpaceForCard(CastleCard card)
	{
		highlightedSpaceIndices.Clear();
		if (engine != null && engine.State != null)
		{
			if (card.Color.HasValue && card.Shape.HasValue)
			{
				var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Color == card.Color && s.Shape == card.Shape);
				if (space != null)
					highlightedSpaceIndices.Add(space.Index);
			}
			else if (card.IsHero && card.Color.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Color == card.Color).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else if (card.IsAnyColor && card.Shape.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Shape == card.Shape).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else
			{
				highlightedSpaceIndices.Clear();
			}
		}
		StateHasChanged();
	}

	void ClearHighlight()
	{
		highlightedSpaceIndices.Clear();
		StateHasChanged();
	}
	GameEngine? engine = null;
	int playerCount = 4;
	bool started = false;

	void StartGame()
	{
		engine = new GameEngine(playerCount);
		started = true;
	}

	void DrawCardForCurrentPlayer()
	{
		if (phase == TurnPhase.DrawCard && engine != null && engine.State != null)
		{
			engine.DrawCard(engine.State.CurrentPlayer);
			phase = TurnPhase.Action;
			StateHasChanged();
		}
	}

	void SelectCard(int cardIndex)
	{
		selectedCardIndex = cardIndex;
		if (engine != null && engine.State != null && engine.State.PlayerHands[engine.State.CurrentPlayer].Count > cardIndex)
		{
			var card = engine.State.PlayerHands[engine.State.CurrentPlayer][cardIndex];
			HighlightSpaceForCard(card);
		}
		StateHasChanged();
	}

	void PlayCardOnSpace(int playerIndex, int cardIndex, int spaceIndex)
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			if (playerIndex < 0 || playerIndex >= engine.State.PlayerHands.Count)
				return;
			if (cardIndex < 0 || cardIndex >= engine.State.PlayerHands[playerIndex].Count)
				return;
			bool played = engine.PlayCardOnSpace(playerIndex, cardIndex, spaceIndex);
			if (played)
			{
				selectedCardIndex = null;
				selectedPlayerIndex = null;
				// Remain in Action phase so Move Monsters is still active
			}
			StateHasChanged();
		}
	}

	bool CanPlayCardOnSpace(CastleCard card, BoardSpace space)
	{
		if (card == null) return false;
		if (card.Color.HasValue && card.Shape.HasValue)
			return card.Color == space.Color && card.Shape == space.Shape;
		if (card.IsHero && card.Color.HasValue)
			return card.Color == space.Color;
		if (card.IsAnyColor && card.Shape.HasValue)
			return card.Shape == space.Shape;
		return false;
	}

	void MoveMonstersPhase()
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			engine.MoveMonsters();
			phase = TurnPhase.DrawMonster;
			StateHasChanged();
		}
	}

	void DrawMonsterPhase()
	{
		if (phase == TurnPhase.DrawMonster && engine != null && engine.State != null)
		{
			engine.DrawMonster();
			// TODO: Implement monster action
			phase = TurnPhase.DrawCard;
			engine.State.CurrentPlayer = (engine.State.CurrentPlayer + 1) % engine.State.PlayerCount;
			StateHasChanged();
		}
	}
}

