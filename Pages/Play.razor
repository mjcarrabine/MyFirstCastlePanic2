@page "/play"
@using MyFirstCastlePanic.GameLogic

<PageTitle>Play Game</PageTitle>

<h1>Play My First Castle Panic</h1>

@if (!started)
{
	<label>Number of Players:
		<input type="number" min="2" max="4" @bind="playerCount" />
	</label>
	<button @onclick="StartGame">Start Game</button>
}
else if (engine != null && engine.State != null)
{
	<p>Game started with @playerCount players.</p>
	<p>Current Player: @(engine.State.CurrentPlayer + 1)</p>
	<!-- Phase indicator removed -->

	<div style="display: flex; flex-direction: row; align-items: flex-start; gap: 2em; margin-top: 2em;">
		<!-- Game board on the left -->
		<section style="flex: 2 1 0; min-width: 350px;">
			<h2>Board Spaces</h2>
			<ul>
				@foreach (var space in (engine != null && engine.State != null ? engine.State.BoardSpaces : new List<BoardSpace>()))
				{
					var hasMonster = (engine != null && engine.State != null) ? engine.State.MonstersOnBoard.Any(m => m.SpaceIndex == space.Index) : false;
					var showPlayButton = false;
					CastleCard? cardToPlay = null;
					if (phase == TurnPhase.Action && selectedCardIndex.HasValue && selectedPlayerIndex.HasValue && engine != null && engine.State != null)
					{
						int pIdx = selectedPlayerIndex.Value;
						int cIdx = selectedCardIndex.Value;
						if (pIdx >= 0 && pIdx < engine.State.PlayerHands.Count && cIdx >= 0 && cIdx < engine.State.PlayerHands[pIdx].Count)
						{
							cardToPlay = engine.State.PlayerHands[pIdx][cIdx];
							showPlayButton = hasMonster && CanPlayCardOnSpace(cardToPlay, space);
							if (cardToPlay != null && cardToPlay.IsUtility && hasMonster)
							{
								showPlayButton = true;
							}
						}
					}
					if (space.Index == 10)
					{
						<li style="background-color:#f5f5dc; border:2px solid #8d5524; font-weight:bold;">
							10: <span style="font-size:2em; vertical-align:middle; color:#8d5524;">üè∞</span> Wall & Castle
							<span>
								@foreach (var monster in (engine != null && engine.State != null ? engine.State.MonstersOnBoard.Where(m => m.SpaceIndex == space.Index) : Enumerable.Empty<MonsterToken>()))
								{
									<span style="margin-left:10px;">@monster.Type @((monster.IsStarred ? "‚òÖ" : ""))</span>
								}
								@if (showPlayButton)
								{
									<button @onclick="() => { if (selectedCardIndex.HasValue && selectedPlayerIndex.HasValue && engine != null && engine.State != null) PlayCardOnSpace(selectedPlayerIndex.Value, selectedCardIndex.Value, space.Index); }">Catch Monster</button>
								}
							</span>
						</li>
					}
					else
					{
						<li style="@(highlightedSpaceIndices.Contains(space.Index) ? "background-color: yellow;" : "")">
							@space.Index: <span style="@GetColorStyle(space.Color); font-size:2em; vertical-align:middle;">@GetShapeIcon(space.Shape)</span>
							<span>
								@foreach (var monster in (engine != null && engine.State != null ? engine.State.MonstersOnBoard.Where(m => m.SpaceIndex == space.Index) : Enumerable.Empty<MonsterToken>()))
								{
									<span style="margin-left:10px;">@monster.Type @((monster.IsStarred ? "‚òÖ" : ""))</span>
								}
								@if (showPlayButton)
								{
									<button @onclick="() => { if (selectedCardIndex.HasValue && selectedPlayerIndex.HasValue && engine != null && engine.State != null) PlayCardOnSpace(selectedPlayerIndex.Value, selectedCardIndex.Value, space.Index); }">Catch Monster</button>
								}
							</span>
						</li>
					}
				}
			</ul>
		</section>
		<!-- Player hands on the right -->
		<section style="flex: 1 1 0; min-width: 250px; background:#f8f9fa; border-radius:10px; box-shadow:0 1px 6px #ccc; padding:1em;">
			<h2>Player Hands</h2>
			@if (engine != null && engine.State != null)
			{
				@for (int i = 0; i < engine.State.PlayerHands.Count; i++)
				{
					<div style="@(i == engine.State.CurrentPlayer ? "background-color: #e3f2fd; border: 2px solid #1976d2; padding: 0.5em; margin-bottom: 0.5em;" : "margin-bottom: 0.5em;")">
						<strong>Player @(i+1):</strong>
						<div style="display: flex; flex-direction: row; gap: 0.5em; align-items: flex-start; margin-top: 0.5em;">
							@for (int j = 0; j < engine.State.PlayerHands[i].Count; j++)
							{
								var card = engine.State.PlayerHands[i][j];
								var cardIdx = j;
								var playerIdxForButton = i;
								var cardIdxForButton = cardIdx;
								<div @onmouseover="() => HighlightSpaceForCard(card)" @onmouseout="ClearHighlight"
									 style="min-width: 90px; min-height: 60px; padding: 0.5em; margin: 0; display: flex; flex-direction: column; align-items: flex-start; justify-content: center; box-sizing: border-box; border-radius: 8px; background: #fff; box-shadow: 0 1px 4px #bbb; cursor: pointer; @(selectedCardIndex == cardIdx && selectedPlayerIndex == i ? "background-color: #fff3cd; border: 3px solid #ff5722; box-shadow: 0 0 8px #ff9800;" : "border: 1px solid #ccc;")">
									@if (card.Color.HasValue && card.Shape.HasValue)
									{
										<span style="display: flex; align-items: center; gap: 0.3em;">
											<span style="@GetColorStyle(card.Color.Value); font-size:2em; vertical-align:middle;">@GetShapeIcon(card.Shape.Value)</span>
										</span>
									}
									else if (card.IsHero)
									{
										<span style="font-weight:bold;">Hero: @card.Name</span>
									}
									else if (card.IsAnyColor && card.Shape.HasValue)
									{
										<span style="display: flex; align-items: center; gap: 0.3em; font-weight:bold;">
											@card.Shape
											@foreach (var color in new[] { MyFirstCastlePanic.GameLogic.CardColor.Blue, MyFirstCastlePanic.GameLogic.CardColor.Green, MyFirstCastlePanic.GameLogic.CardColor.Red })
											{
												<span style="@GetColorStyle(color); font-size:2em; vertical-align:middle;">@GetShapeIcon(card.Shape.Value)</span>
											}
										</span>
									}
									else if (card.IsUtility)
									{
										<span style="font-weight:bold;">Utility: @card.Name</span>
									}
									else
									{
										<span>@card.Name</span>
									}
									@if (phase == TurnPhase.Action)
									{
										<button @onclick="() => SelectCardForPlayer(playerIdxForButton, cardIdxForButton)" style="margin-top: 0.3em;">Play Card</button>
									}
								</div>
							}
						</div>
					</div>
				}
				<div style="margin-top:1.5em; display:flex; gap:1em;">
					<button @onclick="DrawCardForCurrentPlayer" disabled="@(phase != TurnPhase.DrawCard)">Draw Card</button>
					<button @onclick="MoveMonstersPhase" disabled="@(phase != TurnPhase.Action)">Move Monsters</button>
					<button @onclick="DrawMonsterPhase" disabled="@(phase != TurnPhase.DrawMonster)">Draw Monster</button>
					<button @onclick="() => { if (engine != null) engine.CheckGameOver(); }">Check Game Over</button>
				</div>
			}
		</section>
	</div>

	<section style="background:#eee; padding:0.5em; margin:1.5em 0 1em 0; border-radius:8px; box-shadow:0 1px 4px #bbb;" id="debug-output-section">
		<button @onclick="CopyDebugOutput" style="float:right; margin-bottom:0.5em;">Copy Debug Output</button>
		@if (!string.IsNullOrEmpty(selectCardError))
		{
			<div style="color: red; font-weight: bold;">@selectCardError</div>
		}
		@if (selectedPlayerIndex.HasValue && selectedCardIndex.HasValue && engine != null && engine.State != null && selectedPlayerIndex.Value >= 0 && selectedPlayerIndex.Value < engine.State.PlayerHands.Count && selectedCardIndex.Value >= 0 && selectedCardIndex.Value < engine.State.PlayerHands[selectedPlayerIndex.Value].Count)
		{
			<div><strong>Selected Card:</strong> @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].Name) (Color: @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].Color), Shape: @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].Shape), Hero: @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].IsHero), AnyColor: @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].IsAnyColor), Utility: @(engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value].IsUtility))</div>
		}
		else
		{
			<div><strong>Selected Card:</strong> None</div>
		}
		<br />
		<strong>Monsters on Board:</strong>
		<ul>
			@if (engine != null && engine.State != null)
			{
				foreach (var m in engine.State.MonstersOnBoard)
				{
					var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Index == m.SpaceIndex);
					<li>Monster: @m.Type @(m.IsStarred ? "‚òÖ" : "") on Space @m.SpaceIndex (@(space != null ? space.Color + " " + space.Shape : "Unknown"))</li>
				}
			}
		</ul>
	</section>
}

@code {
	[Inject] private IJSRuntime JS { get; set; } = default!;

	private string? selectCardDebugTrace = null;

	private async Task CopyDebugOutput()
	{
		// Get the debug output as plain text
		var debugText = GetDebugOutputText();
		await JS.InvokeVoidAsync("navigator.clipboard.writeText", debugText);
	}

	private string GetDebugOutputText()
	{
		var sb = new System.Text.StringBuilder();
		sb.AppendLine($"Phase: {phase}");
		sb.AppendLine($"Selected Player Index: {selectedPlayerIndex}");
		sb.AppendLine($"Selected Card Index: {selectedCardIndex}");
		if (selectedPlayerIndex.HasValue && selectedCardIndex.HasValue && engine != null && engine.State != null && selectedPlayerIndex.Value >= 0 && selectedPlayerIndex.Value < engine.State.PlayerHands.Count && selectedCardIndex.Value >= 0 && selectedCardIndex.Value < engine.State.PlayerHands[selectedPlayerIndex.Value].Count)
		{
			var debugCard = engine.State.PlayerHands[selectedPlayerIndex.Value][selectedCardIndex.Value];
			sb.AppendLine($"Selected Card: {debugCard.Name} (Color: {debugCard.Color}, Shape: {debugCard.Shape}, Hero: {debugCard.IsHero}, AnyColor: {debugCard.IsAnyColor}, Utility: {debugCard.IsUtility})");
		}
		else
		{
			sb.AppendLine("Selected Card: None");
		}
		sb.AppendLine();
		sb.AppendLine("Monsters on Board:");
		if (engine != null && engine.State != null)
		{
			foreach (var m in engine.State.MonstersOnBoard)
			{
				var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Index == m.SpaceIndex);
				sb.AppendLine($"Monster: {m.Type}{(m.IsStarred ? " ‚òÖ" : "")} on Space {m.SpaceIndex} ({(space != null ? space.Color + " " + space.Shape : "Unknown")})");
			}
		}
		sb.AppendLine("Board Spaces (for Catch Monster diagnosis):");
		if (engine != null && engine.State != null && selectedPlayerIndex.HasValue && selectedCardIndex.HasValue)
		{
			var pIdx = selectedPlayerIndex.Value;
			var cIdx = selectedCardIndex.Value;
			CastleCard? cardToPlay = null;
			if (pIdx >= 0 && pIdx < engine.State.PlayerHands.Count && cIdx >= 0 && cIdx < engine.State.PlayerHands[pIdx].Count)
			{
				cardToPlay = engine.State.PlayerHands[pIdx][cIdx];
			}
			foreach (var space in engine.State.BoardSpaces)
			{
				var hasMonster = engine.State.MonstersOnBoard.Any(m => m.SpaceIndex == space.Index);
				var canPlay = cardToPlay != null && CanPlayCardOnSpace(cardToPlay, space);
				var isUtility = cardToPlay != null && cardToPlay.IsUtility;
				sb.AppendLine($"Space {space.Index}: Monster? {hasMonster}, CanPlay? {canPlay}, Utility? {isUtility}, ShowButton? {hasMonster && (canPlay || isUtility)}");
			}
		}
		return sb.ToString();
	}
	// Add TurnPhase enum for local use
	enum TurnPhase { DrawCard, Action, DrawMonster }

	// Track the current phase
	TurnPhase phase = TurnPhase.DrawCard;

	// Track the selected card and player
	int? selectedCardIndex = null;
	int? selectedPlayerIndex = null;

	// Allow selecting any card from any player
	string? selectCardError = null;
	void SelectCardForPlayer(int playerIndex, int cardIndex)
	{
		selectCardError = null;
		selectedPlayerIndex = playerIndex;
		selectedCardIndex = cardIndex;
		selectCardDebugTrace = $"SelectCardForPlayer called: playerIndex={playerIndex}, cardIndex={cardIndex} | After set: selectedPlayerIndex={selectedPlayerIndex}, selectedCardIndex={selectedCardIndex}";
		Console.WriteLine($"[DEBUG] SelectCardForPlayer called: playerIndex={playerIndex}, cardIndex={cardIndex}");
		Console.WriteLine($"[DEBUG] After set: selectedPlayerIndex={selectedPlayerIndex}, selectedCardIndex={selectedCardIndex}");
		if (engine != null && engine.State != null)
		{
			if (playerIndex < 0 || playerIndex >= engine.State.PlayerHands.Count)
			{
				selectCardError = $"Invalid player index: {playerIndex}";
				StateHasChanged();
				return;
			}
			if (cardIndex < 0 || cardIndex >= engine.State.PlayerHands[playerIndex].Count)
			{
				selectCardError = $"Invalid card index: {cardIndex} for player {playerIndex}";
				StateHasChanged();
				return;
			}
			var card = engine.State.PlayerHands[playerIndex][cardIndex];
			HighlightSpaceForCard(card);
		}
		// Ensure UI updates so Catch Monster button appears
		StateHasChanged();
	}
	// GetPhaseLabel removed
	string GetColorStyle(MyFirstCastlePanic.GameLogic.CardColor color)
	{
		return color switch
		{
			MyFirstCastlePanic.GameLogic.CardColor.Blue => "color:blue;",
			MyFirstCastlePanic.GameLogic.CardColor.Green => "color:green;",
			MyFirstCastlePanic.GameLogic.CardColor.Red => "color:red;",
			_ => ""
		};
	}


	string GetShapeIcon(MyFirstCastlePanic.GameLogic.CardShape shape)
	{
		return shape switch
		{
			MyFirstCastlePanic.GameLogic.CardShape.Square => "‚ñ†",
			MyFirstCastlePanic.GameLogic.CardShape.Triangle => "‚ñ≤",
			MyFirstCastlePanic.GameLogic.CardShape.Circle => "‚óè",
			_ => ""
		};
	}

	List<int> highlightedSpaceIndices = new();
	void HighlightSpaceForCard(CastleCard card)
	{
		highlightedSpaceIndices.Clear();
		if (engine != null && engine.State != null)
		{
			if (card.Color.HasValue && card.Shape.HasValue)
			{
				var space = engine.State.BoardSpaces.FirstOrDefault(s => s.Color == card.Color && s.Shape == card.Shape);
				if (space != null)
					highlightedSpaceIndices.Add(space.Index);
			}
			else if (card.IsHero && card.Color.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Color == card.Color).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else if (card.IsAnyColor && card.Shape.HasValue)
			{
				var spaces = engine.State.BoardSpaces.Where(s => s.Shape == card.Shape).Select(s => s.Index);
				highlightedSpaceIndices.AddRange(spaces);
			}
			else
			{
				highlightedSpaceIndices.Clear();
			}
		}
		StateHasChanged();
	}

	void ClearHighlight()
	{
		highlightedSpaceIndices.Clear();
		StateHasChanged();
	}
	GameEngine? engine = null;
	int playerCount = 4;
	bool started = false;

	void StartGame()
	{
		engine = new GameEngine(playerCount);
		started = true;
	}

	void DrawCardForCurrentPlayer()
	{
		if (phase == TurnPhase.DrawCard && engine != null && engine.State != null)
		{
			engine.DrawCard(engine.State.CurrentPlayer);
			phase = TurnPhase.Action;
			StateHasChanged();
		}
	}

	void SelectCard(int cardIndex)
	{
		selectedCardIndex = cardIndex;
		if (engine != null && engine.State != null && engine.State.PlayerHands[engine.State.CurrentPlayer].Count > cardIndex)
		{
			var card = engine.State.PlayerHands[engine.State.CurrentPlayer][cardIndex];
			HighlightSpaceForCard(card);
		}
		StateHasChanged();
	}

	void PlayCardOnSpace(int playerIndex, int cardIndex, int spaceIndex)
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			if (playerIndex < 0 || playerIndex >= engine.State.PlayerHands.Count)
				return;
			if (cardIndex < 0 || cardIndex >= engine.State.PlayerHands[playerIndex].Count)
				return;
			bool played = engine.PlayCardOnSpace(playerIndex, cardIndex, spaceIndex);
			if (played)
			{
				selectedCardIndex = null;
				selectedPlayerIndex = null;
				// Remain in Action phase so Move Monsters is still active
			}
			StateHasChanged();
		}
	}

	bool CanPlayCardOnSpace(CastleCard card, BoardSpace space)
	{
		if (card == null) return false;
		if (card.Color.HasValue && card.Shape.HasValue)
			return card.Color == space.Color && card.Shape == space.Shape;
		if (card.IsHero && card.Color.HasValue)
			return card.Color == space.Color;
		if (card.IsAnyColor && card.Shape.HasValue)
			return card.Shape == space.Shape;
		return false;
	}

	void MoveMonstersPhase()
	{
		if (phase == TurnPhase.Action && engine != null && engine.State != null)
		{
			engine.MoveMonsters();
			phase = TurnPhase.DrawMonster;
			StateHasChanged();
		}
	}

	void DrawMonsterPhase()
	{
		if (phase == TurnPhase.DrawMonster && engine != null && engine.State != null)
		{
			engine.DrawMonster();
			// TODO: Implement monster action
			phase = TurnPhase.DrawCard;
			engine.State.CurrentPlayer = (engine.State.CurrentPlayer + 1) % engine.State.PlayerCount;
			StateHasChanged();
		}
	}
}

